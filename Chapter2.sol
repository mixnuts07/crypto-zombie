** 【ゾンビが人間をおそう】 **
・アドレス ... 銀行口座番号の様なもの。特定のユーザorスマートコントラクトで所有するもの。
ETHのブロックチェーンはアカウント(口座)で構成されている。アカウントにはEtherの残高が記録されている。アカウントにはアドレスがある。
・Mappings ... データを格納。データの保管と参照。キーバリューストア。
// アカウントの残高にuintを格納。(金融系) key=address, value=uint
mapping(address => uint) public accountBalance; 
// ユーザIDをもとにユーザ名を参照・格納 key=uint, value=string
mapping(uint=> string) useIdToName;
・msg.sender...ユーザのaddressを参照できるG変数。関数をcallするときに使用。securityをもたらす。
・require ... 条件を満たさないとエラーを投げて実行STOP.
// require(aa == ??);
   return hoge;
・solidityはネイティブで文字列比較ができない。→keccak256でハッシュを比較!! 
Ex.. require( keccak256(_name) == keccak256("Vital") );

・継承
// BabyDogeはcatchphraseとanotherCatchphrase両方使える。
contract Doge(){
   function catchphrase() public returns (string){
      return "SO WOW CRYPTODOGE";
   }
}
contract BabyDoge is Doge{
   function anotherCatchphrase() public returns (string){
      return "SUCH MOON BABYDOGE";
      }
}

・変数の格納場所 .. storage, memory
storage(HDD) ..チェーン上に永久に格納される変数。状態変数(関数外で宣言された変数)。
memory(RAM) .. 一時的な変数。外部関数をcontractにcallするときに消去される。(関数内で宣言された変数)
EX...
contract SandwichFactory {
  struct Sandwich {
    string name;
    string status;
  }

  Sandwich[] sandwiches;

  function eatSandwich(uint _index) public {
    // 明示的に宣言！
    
    // storage宣言：
    Sandwich storage mySandwich = sandwiches[_index];
    //この場合`mySandwich`がstorage内の`sandwiches[_index]`を示すポインタだから...
    mySandwich.status = "Eaten!";
    // これで sandwiches[_index] をブロックチェーン上でも永久に変更することになる。

    // コピーしたいだけなら memory の方が便利：
    Sandwich memory anotherSandwich = sandwiches[_index + 1];
    // この場合 anotherSandwich は memory内のデータをコピーすることになり
    anotherSandwich.status = "Eaten!";
    // 一時的な変数を変更するだけで sandwiches[_index + 1] にはなんの影響もない。次のようにすることも可能 
    sandwiches[_index + 1] = anotherSandwich;
  }
}

・ビジリティ
private
internalはこのcontractから継承したcontractでもアクセス可能になる！
public
externalはcontractの外からのみ呼び出し可能。

・チェーン上の他人のコントラクトとやり取りするにはinterfaceを定義！
EX. interface
contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}
(Description)
関数自体を定義していない！ ; で終わっている。
このinterfaceをDappsに組みこむことで自分のcontractから他人のcontractの関数が
どんなもの・どう呼び出す・どんな応答か　がわかる。

・interfaceの定義
contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}
これをcontract内で使う。
contract MyContract {
  address NumberInterfaceAddress = 0xab38...; 
  // ここは、イーサリアム上のFavoriteNumberコントラクトのアドレスが入る。
  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);
  // `numberContract`は他のコントラクトを指し示すものになっているぞ 

  function someFunction() public {
    // コントラクトから`getNum`を呼び出せるぞ：
    uint num = numberContract.getNum(msg.sender);
    // ...よし、`num`を操作するぞ。
  }
}
これでEthチェーン上で他のcotractとやり取りできる！
ただし、、関数がpublic OR external　である場合。

・IFステートメント .. JSと同じ？？
function eatBLT(string sandwich) public {
  // 文字列を比較するときに、 keccak256を使って
  // ハッシュを比較したことを思い出してくれよ
  if (keccak256(sandwich) == keccak256("BLT")) {
    eat();
  }
}

まとめ
Ex..JSとWeb3.jsを使用して実行したcontractがやり取りする例

var abi = /* abi generated by the compiler */
var ZombieFeedingContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFeeding = ZombieFeedingContract.at(contractAddress)

// ゾンビのIDと捕食したい子猫のIDをすでに持っているものとする。
let zombieId = 1;
let kittyId = 1;

// クリプトキティの画像を取得するにはweb APIに照会する必要がある。
// この情報はブロックチェーンにはない。ウェブサーバーにあるだけだ。
// もし全ての情報がブロックチェーン上に格納されていれば、サーバーの
// 障害を心配することはなくなるがな。まぁこのゾンビゲームを気に入ってもらえなければ、
// APIを変更するか我々のアクセスをブロックするだけだ。問題ない ;)
let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId
$.get(apiUrl, function(data) {
  let imgUrl = data.image_url
  // 画像を表示する部分だ
})

// ユーザーが子猫をクリックししたときの処理だ：
$(".kittyImage").click(function(e) {
  // コントラクトの`feedOnKitty` メソッドを呼び出す
  ZombieFeeding.feedOnKitty(zombieId, kittyId)
})

// コントラクトのNewZombieイベントをリッスンして表示できるようにする部分だ： 
ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  // この関数はレッスン1でやったのと同じようにゾンビを表示するものだ：
  generateZombie(result.zombieId, result.name, result.dna)
})
  
  
  
