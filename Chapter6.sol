// web3.js .. Ethereum FoundationのJavaScriptライブラリ

・コントラクトの呼び出し
イーサリアムのネットワークは、ブロックチェーンのコピーをそれぞれ持ったノードで構成されていることを思い出すのだ。
スマートコントラクトの関数を呼び出したい時、これらノードのどれか一つをクエリする必要がある:

スマートコントラクトのアドレス
呼び出したい関数。そして、
その関数に渡したい変数


イーサリアムのノードは、人間が読むことができない JSON-RPC という言語でのみ会話する。
コントラクトの関数を呼び出したいとノードに伝えるクエリはこんな感じのものだ:

// うむ...関数呼び出しは全てこうやって書くのだ、頑張れ!
{"jsonrpc":"2.0","method":"eth_sendTransaction","params":
[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":
"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0",
"gasPrice":"0x9184e72a000","value":"0x9184e72a","data":
"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}



幸運にもWeb3.jsはサーフェイスの下にこの面倒なクエリを隠してくれるから、
便利で読みやすいJavaScriptインターフェイスとやり取りするだけで良い。

上のクエリを構成する代わりに、コード中で関数を呼び出すのはこんな感じになる:

cryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")
  .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })
  
  
・install
// NPMを使用
npm install web3

// Yarnを使用
yarn add web3

// Bowerを使用
bower install web3


・web3プロバイダ(infura) .. どのノード に読み書きを処理させるよう働き掛けるかをコードに教えてくれる。(APIの様なもの)→URLの設定みたいなやつ。

よし! Web3.jsがプロジェクトで使えるようになったから、今度はこれを初期化してブロックチェーンにアクセスできるようにしていこう。

まず必要なのは、 Web3プロバイダ というものだ。

イーサリアムは ノード で構成されていて、全ノードが同じデータのコピーをシェアしていることを覚えているだろうか。
Web3.jsにおけるWeb3プロバイダの設定は、 どのノード に読み書きを処理させるよう働き掛けるかをコードに教えてくれる。
これは従来のウェブアプリでAPIコールをするためにリモートのウェブサーバーのURLを設定するようなものだ。

自分のイーサリアム・ノードをプロバイダとして運営することも可能だが、
もっと手軽なサードパーティのサービスがあるから、DAppのユーザーのために自分のイーサリアム・ノードをもつ必要はない。
そのサービスとは Infura だ。


・infura
Infura とは、高速な読み込みのためのキャッシュレイヤーをもつイーサリアム・ノードのセットを保持するサービスで、
API経由でこれらノードに無料でアクセスで可能だ。 
Infuraをプロバイダとして使用することで、自分のノードをセットアップして維持しなくても、イーサリアムブロックチェーンとメッセージをしっかりと送受信できる。
Ex.
var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));


・秘密鍵管理(Metamask)
だが我々のDAppは今後多くのユーザーが使用し、彼らはブロックチェーンの読み取りだけでなく書き込みも行っていく
- だからユーザーが秘密鍵でトランザクションに署名する方法が必要となるのだ。


注：イーサリアム（そして一般的なブロックチェーン）は、
トランザクションにデジタル署名をするために公開鍵/秘密鍵のペアを使用します。
これはデジタル署名向けの非常に安全なパスワードであると考えてください。
このようにして、もしあなたがブロックチェーンのデータを変更すると、
あなたは自分の公開鍵を通じてそれを署名した人であると証明することができます。
しかし誰もあなたの秘密鍵は知らないので、あなたに代わってトランザクションを偽造することはできません。

暗号化の方法は複雑だから、お主がセキュリティの専門家で何を行っているかを本当にわかっているわけでもない限り、
アプリのフロントエンドでユーザーの秘密鍵を自ら管理しようとするのは良い考えではない。

だがラッキーなことに秘密鍵管理の必要はない
— すでにこれを行ってくれるサービスがあるのだ。中でももっともポピュラーなサービスは Metamask だ。


・Metamask
MetamaskはChromeとFirefoxのブラウザ拡張機能で、
ユーザーは自分のイーサリアム・アカウントと秘密鍵を安全に管理し、
そのアカウントでWeb3.jsを使用しているウェブサイトとやりとりすることが可能だ
（もし以前使ったことがなければ、絶対にインストールしたいはずだ 
- 自分のブラウザがWeb3に対応して、イーサリアムのブロックチェーンと通信するウェブサイトと対話できるようになるのだ！)。

そして（我々がCryptoZombiesゲームでやっているように）
ユーザーにブラウザのウェブサイトを通してDAppとやりとりさせたい場合、
開発者としてMetamaskと互換性のあるものにしたいと絶対思うだろう。

注: Metamaskは、先ほどやったようにInfuraのサーバーをWeb3プロバイダーとして使用しますが
、Web3プロバイダーを選択するオプションも提供しています。
MetamaskのWeb3プロバイダを使用することでユーザーに選択肢を与えるので、アプリでの懸念事項が少なくなります。


・web3プロバイダの使用（Metamask）
Metamaskは、web3プロバイダをJavaScriptのグローバルオブジェクト web3のブラウザにインジェクトする。
なので web3が存在するか、そしてプロバイダとしてweb3.currentProviderを使用しているかをアプリがチェックすることができる。

ここにあるMetamaskが提供するテンプレートコードは、ユーザーがMetamaskをインストール済みかを検出し、
インストールしていなければアプリを使用するためにMetamaskのインストールが必要だと伝えるものだ:

window.addEventListener('load', function() {

  // Web3がブラウザにインジェクトされているかチェック (Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // Mist/MetaMaskのプロバイダの使用
    web3js = new Web3(web3.currentProvider);
  } else {
    // ユーザーがweb3を持たない場合の対処。
    // アプリを使用するためにMetamaskをインストールするよう
    // 伝えるメッセージを表示。
  }

  // アプリのスタート＆Web3.jsへの自由なアクセスが可能に:
  startApp()

})


・コントラクタへのアクセス
Web3.jsをMetamaskのWeb3プロバイダで初期化できたから、今度はスマートコントラクトにアクセスできるように設定しよう。

Web3.jsがコントラクトにアクセスするため、必要となるものが２つある: コントラクトの アドレス と ABI だ。


・コントラクタアドレス
スマートコントラクトを書き終えたあと、それをコンパイルしてイーサリアムにデプロイする。 
次のレッスン で デプロイ を扱うが、これはコードを書くこととはあまりに違ったプロセスだ。
だから順番を変えてまずはWeb3.jsをやっていくことにした。

コントラクトをデプロイすると、永久に有効なイーサリアム上の固定アドレスが与えられる
。レッスン２を振り返ると、イーサリアム・メインネット上のCryptoKittiesコントラクトアドレスは0x06012c8cf97BEaD5deAe237070F9587f8E7A266dである。

デプロイ後スマートコントラクトにアクセスするために、このアドレスをコピーしておくことが必要だ。


・コントラクタABI .. (Application Binary Interface)  web3.jsがコントラクタにアクセスするためにさらに必要なもの。
基本的にこれはコントラクトのメソッドをJSON形式で表していて、関数コールをコントラクトが理解できるようフォーマットする方法を、Web3.jsに教えてくれるものだ。
関数呼び出し方法をweb3.jsに教える？？


イーサリアムにデプロイするためにコントラクトをコンパイルする際（レッスン7でこれは説明しよう）、
SolidityコンパイラはABIを提供してくれるので、コントラクトアドレスに加えてこれをコピーして保存しておかなくてはならない。


これでweb3.jsを使ってコントラクトにアクセス可能になった！
web3.jsでコントラクトの関数を呼び出すための２つのメソッドがある。（call, send）


// Call
callはview関数およびpure関数に使われる。
これはローカルのノードでのみ機能し、ブロックチェーン上のトランザクションを生成しない。

復習: viewおよびpure関数は、読み取り専用のものでブロックチェーン上のステートを変更しません。
またガスを必要とせず、ユーザーがMetamaskを使ってトランザクションに署名することも要求されません。

Web3.jsを使って、次のように123をパラメーターにしてmyMethodという名の関数をcallできる:

myContract.methods.myMethod(123).call()


// Send
sendはトランザクションを生成し、ブロックチェーン上のデータを変更する。
viewまたはpureではない関数には、sendを使う必要がある。

注: トランザクションをsendすることはユーザーにガスの支払いを要求し、
また彼らがトランザクションに署名するようMetamaskをポップアップします。
Web3プロバイダとしてMetamaskを使用する場合、send()関数を呼び出すとこれを全部行ってくれるので
、コード内で特別なことを行う必要はありません。

Web3.jsを使って、次のように123をパラメーターにして、myMethodという名の関数を呼び出すトランザクションをsendすることができる:

myContract.methods.myMethod(123).send()


Ex. Callメソッド
function getZombieDetails(id) {
  return cryptoZombies.methods.zombies(id).call();
}

// 関数を呼び出し、その結果を処理する:
getZombieDetails(15)
.then(function(result) {
  console.log("Zombie 15: " + JSON.stringify(result));
});

ここで何が起こっているのか、一緒に見ていこう。

cryptoZombies.methods.zombies(id).call() はWeb3プロバイダのノードと通信して、コントラクトにあるZombie[] public zombiesからゾンビとそのインデックスidを返す。

これは外部サーバーへのAPIコールのように非同期であることに注意するのだ。
だからWeb3はここでpromiseを返すことになる。

このPromiseがリゾルブすると(Web3プロバイダからの応答を受けとったという意味だ)、
この見本コードはthenステートメントで続行され、resultをコンソールにログする。

result は次のようなJavaScriptオブジェクトとなる:

{
  "name": "H4XF13LD MORRIS'S COOLER OLDER BROTHER",
  "dna": "1337133713371337",
  "level": "9999",
  "readyTime": "1522498671",
  "winCount": "999999999",
  "lossCount": "0" // Obviously.
}
このオブジェクトを解析してフロントエンドロジックを用意すると、意味がわかるようにフロントエンドに表示することができる。


